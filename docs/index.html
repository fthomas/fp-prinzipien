<!DOCTYPE html>
<html>
  <head>
    <title>Patterns der funktionalen Programmierung</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Patterns der funktionalen Programmierung
## Frank Thomas

---

# Kernprinzipien funktionalen Designs

* **Funktionen**

* **Typen**

* **Komposition**

???
      
Funktionen:
* im mathematischen Sinn, d.h. eine Abbildung zwischen zwei Mengen ohne Seiteneffekte
* mit leichtgewichtiger Syntax;
* können Parameter und Rückgabewerte sein und Variablen zugewiesen werden

Typen:
* Datentypen wie Produkttypen und Summentypen
* Typparameter
* sind Dokumentation und leiten uns bei der Implementierung      

Komposition:
* größere Komponenten können aus Kleineren zusammengesetzt werden
* Komponenten können isoliert verwendet, getestet und verstanden werden

---

# Funktionen

FP ist programmieren mit *reinen* Funktionen

Reine Funktionen haben keine Seiteneffekte wie z.B.

* Variablen ändern
* Datenstrukturen ändern
* Exceptions werfen
* Dateien lesen oder schreiben
* Benutzereingaben lesen oder Ausgaben auf die Konsole schreiben

<center>
<br \>
FP schränkt ein <i>wie</i> wir Programme schreiben,<br \>
aber nicht <i>welche</i> wir schreiben können
</center>

---

# Warum das Ganze?

Alles was eine Funktion macht wird durch deren Rückgabewert repräsentiert.  

* Funktionen sind einfacher zu verstehen
* Testbarkeit
* Komposition
* Refactoring
* FP macht glücklich

???

* Eine Funktion beschreibt was man will anstatt zu sagen wie man es bekommt.
* Einfacher zu verstehen, weil ihre Logik vom Erlangen der Eingaben und der Interpretation getrennt ist
* Zum Testen reicht es die Rückgabewerte zu inspizieren - es sind keine Mocks oder Spies nötig.
* Da keine Seiteneffekte ausgeführt werden ist es einfacher Komponenten wiederzuverwenden
  und miteinander zu kombinieren.
* Da keine Seiteneffekte ausgeführt werden, kann man Ausdrücke Variablen zuweisen und gleiche
  Ausdrücke durch die Variable ersetzen.

---
class: center, middle

# Praxisbeispiel

Wir wollen ein kleines rein funktionales Programm schreiben, dass mit dem Benutzer interagiert
und einen Key Value Store verwendet.

---

# What have we learned?

* Programme sind Werte
* große Programme werden kleineren Programmen zusammengebaut
* Seiteneffekte werden von Interpretern ausgeführt
* Schleifen können durch Rekursion abgebildet werden
* Datentypen für verschiedene Effekte (z.B. `ConsoleIO` und `KVStore`)
* Interpreter müssen nicht immer Seiteneffekte ausführen
* Um verschiedene Effekte zu kombinieren brauchen wir eine gemeinsame "Sprache"

???

* Aufruf des Interpreters ist der letzte Aufruf in unserem Programm
  und passiert hauptsächlich in der main-Methode    

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
