<!DOCTYPE html>
<html>
  <head>
    <title>Patterns der funktionalen Programmierung</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Patterns der funktionalen Programmierung
## Frank Thomas

???

Ziel dieses Vortrags ist zu zeigen wie man ein Programm rein funktional schreiben kann.

---

# Kernprinzipien funktionalen Designs

* **Funktionen**

* **Typen**

* **Komposition**

???
      
Funktionen:
* im mathematischen Sinn, d.h. eine Abbildung zwischen zwei Mengen ohne Seiteneffekte
* mit leichtgewichtiger Syntax
* können Parameter und Rückgabewerte sein und Variablen zugewiesen werden

Typen:
* Datentypen wie Produkttypen und Summentypen
* Typparameter
* sind Dokumentation und leiten uns bei der Implementierung      

Komposition:
* größere Komponenten können aus Kleineren zusammengesetzt werden
* Komponenten können isoliert verwendet, getestet und verstanden werden

---

# Funktionen

FP ist programmieren mit **reinen** Funktionen

Reine Funktionen haben keine Seiteneffekte wie z.B.

* Variablen ändern

* Datenstrukturen ändern

* Exceptions werfen

* Dateien lesen oder schreiben

* Benutzereingaben lesen oder Ausgaben auf die Konsole schreiben

<center>
<br \>
FP schränkt ein <b>wie</b> wir Programme schreiben,<br \>
aber nicht <b>welche</b> wir schreiben können
</center>

---

# Warum das Ganze?

Alles was eine Funktion macht wird durch deren Rückgabewert repräsentiert.  

* Funktionen sind einfacher zu verstehen

* Testbarkeit

* Komposition

* Refactoring

* FP macht glücklich ☺

???

* Einfacher zu verstehen, weil ihre Logik vom Erlangen der Eingaben und der Interpretation getrennt ist

* Zum Testen reicht es die Rückgabewerte zu inspizieren - es sind keine Mocks oder Spies nötig

* Da keine Seiteneffekte ausgeführt werden ist es einfacher Komponenten wiederzuverwenden
  und miteinander zu kombinieren

* Da keine Seiteneffekte ausgeführt werden, kann man Ausdrücke Variablen zuweisen und gleiche
  Ausdrücke durch die Variable ersetzen

* man schafft verständliche, wiederverwendbare und einfach zu testende Komponenten

---
class: center, middle

# Beispiel

Eine minimalistische Shell für eine Key-Value-Datenbank

---

# Zusammenfassung

* Programme sind Werte

* große Programme werden aus kleineren Programmen zusammengebaut

* Seiteneffekte werden von Interpretern ausgeführt

* Interpreter müssen nicht immer Seiteneffekte ausführen

* Schleifen können durch Rekursion abgebildet werden

* Datentypen für verschiedene Effekte (z.B. `ConsoleIO` und `KVStore`)

???

* Aufruf des Interpreters ist der letzte Aufruf in unserem Programm
  und passiert hauptsächlich in der main-Methode    

---
class: center, middle

# THE END

Slides: <https://fthomas.github.io/fp-prinzipien/>

Code: <https://github.com/fthomas/fp-prinzipien>
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
