<!DOCTYPE html>
<html>
  <head>
    <title>Patterns der funktionalen Programmierung</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Patterns der funktionalen Programmierung
## Frank Thomas

???

Ziel dieses Vortrags ist zu zeigen wie man ein Programm rein funktional schreiben kann.

---

# Kernprinzipien funktionalen Designs

* **Funktionen**

* **Typen**

* **Komposition**

???
      
Funktionen:
* im mathematischen Sinn, d.h. eine Abbildung zwischen zwei Mengen ohne Seiteneffekte
* mit leichtgewichtiger Syntax
* k√∂nnen Parameter und R√ºckgabewerte sein und Variablen zugewiesen werden

Typen:
* Datentypen wie Produkttypen und Summentypen
* Typparameter
* sind Dokumentation und leiten uns bei der Implementierung      

Komposition:
* gr√∂√üere Komponenten k√∂nnen aus Kleineren zusammengesetzt werden
* Komponenten k√∂nnen isoliert verwendet, getestet und verstanden werden

---

# Funktionen

FP ist programmieren mit **reinen** Funktionen

Reine Funktionen haben keine Seiteneffekte wie z.B.

* Variablen √§ndern

* Datenstrukturen √§ndern

* Exceptions werfen

* Dateien lesen oder schreiben

* Benutzereingaben lesen oder Ausgaben auf die Konsole schreiben

<center>
<br \>
FP schr√§nkt ein <bold>wie</bold> wir Programme schreiben,<br \>
aber nicht <bold>welche</bold> wir schreiben k√∂nnen
</center>

---

# Warum das Ganze?

Alles was eine Funktion macht wird durch deren R√ºckgabewert repr√§sentiert.  

* Funktionen sind einfacher zu verstehen

* Testbarkeit

* Komposition

* Refactoring

* FP macht gl√ºcklich ‚ù§Ô∏è üëç

???

* Einfacher zu verstehen, weil ihre Logik vom Erlangen der Eingaben und der Interpretation getrennt ist

* Zum Testen reicht es die R√ºckgabewerte zu inspizieren - es sind keine Mocks oder Spies n√∂tig

* Da keine Seiteneffekte ausgef√ºhrt werden ist es einfacher Komponenten wiederzuverwenden
  und miteinander zu kombinieren

* Da keine Seiteneffekte ausgef√ºhrt werden, kann man Ausdr√ºcke Variablen zuweisen und gleiche
  Ausdr√ºcke durch die Variable ersetzen

* man schafft verst√§ndliche, wiederverwendbare und einfach zu testende Komponenten

---
class: center, middle

# Beispiel

Eine minimalistische Shell f√ºr eine Key-Value-Datenbank

---

# Zusammenfassung

* Programme sind Werte

* gro√üe Programme werden aus kleineren Programmen zusammengebaut

* Seiteneffekte werden von Interpretern ausgef√ºhrt

* Interpreter m√ºssen nicht immer Seiteneffekte ausf√ºhren

* Schleifen k√∂nnen durch Rekursion abgebildet werden

* Datentypen f√ºr verschiedene Effekte (z.B. `ConsoleIO` und `KVStore`)

???

* Aufruf des Interpreters ist der letzte Aufruf in unserem Programm
  und passiert haupts√§chlich in der main-Methode    

---
class: center, middle

# THE END

Slides: <https://fthomas.github.io/fp-prinzipien/>

Code: <https://github.com/fthomas/fp-prinzipien>
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
